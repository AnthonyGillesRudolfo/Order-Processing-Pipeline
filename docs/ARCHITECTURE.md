<!-- GENERATED BY AugmentCode -->

# Order Processing Pipeline - Restate Architecture

## Overview

This application demonstrates a complete order processing pipeline built with Restate using **Workflows** and **Virtual Objects** in Go, with **PostgreSQL integration** for persistent storage.

## Storage Architecture

### Dual Storage Strategy

The application uses a **dual storage approach** combining Restate's built-in state management with PostgreSQL:

1. **Restate State** (Fast, In-Memory)
   - Workflow and Virtual Object state
   - Fast access during execution
   - Automatically managed by Restate
   - Survives restarts through Restate's journal

2. **PostgreSQL Database** (Persistent, Queryable)
   - Long-term storage for orders, payments, shipments
   - Complex queries and reporting
   - Audit trail and compliance
   - Standard SQL access

### Database Operations

All database writes are wrapped in `restate.Run()` blocks to ensure:
- **Durability**: Operations are journaled by Restate
- **Exactly-once execution**: No duplicate writes on retries
- **Automatic recovery**: Failed operations are retried

## Service Architecture

### 1. **OrderService - WORKFLOW**

The OrderService is implemented as a **Restate Workflow**, which provides:
- **Exactly-once execution** per workflow ID (order ID)
- **Durable state** that persists across restarts
- **Multi-step orchestration** with automatic recovery
- **Workflow key**: Order ID

#### Handlers:
- `CreateOrder` (WorkflowContext) - Main workflow handler that orchestrates the entire order process
- `GetOrder` (WorkflowSharedContext) - Read-only handler to retrieve order details
- `UpdateOrderStatus` (WorkflowContext) - Updates order status in workflow state

#### Workflow Steps:
1. Calculate total amount from items
2. Store order details in workflow state
3. **Persist order to PostgreSQL database** (durable execution)
4. Call Payment Virtual Object to process payment
5. **Update order with payment info in database** (durable execution)
6. Call Shipping Virtual Object to create shipment
7. **Update order with shipment info in database** (durable execution)
8. Mark order as completed
9. **Update final status in database** (durable execution)

#### State Stored:
- `customer_id`: Customer identifier
- `status`: Order status (PENDING → PAID → SHIPPED → COMPLETED)
- `total_amount`: Total order amount
- `payment_id`: Payment transaction ID
- `shipment_id`: Shipment ID
- `tracking_number`: Shipping tracking number

### 2. **PaymentService - VIRTUAL OBJECT**

The PaymentService is implemented as a **Restate Virtual Object**, which provides:
- **Stateful processing** keyed by payment ID
- **Single-writer consistency** per payment ID
- **Built-in K/V state** for payment data
- **Idempotent operations** - returns existing status if already processed

#### Handlers:
- `ProcessPayment` (ObjectContext) - Processes payment with durable execution

#### State Stored:
- `status`: Payment status (PAYMENT_PENDING → PAYMENT_COMPLETED/PAYMENT_FAILED)
- `order_id`: Associated order ID
- `amount`: Payment amount

#### Features:
- Checks if payment already processed (idempotency)
- **Creates payment record in PostgreSQL** (durable execution)
- Durable execution for payment transaction
- **Updates payment status in database** (durable execution)
- Stores payment state in Restate for fast access

### 3. **ShippingService - VIRTUAL OBJECT**

The ShippingService is implemented as a **Restate Virtual Object**, which provides:
- **Stateful tracking** keyed by shipment ID
- **Single-writer consistency** per shipment ID
- **Built-in K/V state** for shipment data
- **Read-only tracking** via shared handler

#### Handlers:
- `CreateShipment` (ObjectContext) - Creates shipment with durable execution
- `TrackShipment` (ObjectSharedContext) - Read-only handler for tracking

#### State Stored:
- `status`: Shipment status (SHIPMENT_CREATED → SHIPMENT_IN_TRANSIT → SHIPMENT_DELIVERED)
- `order_id`: Associated order ID
- `tracking_number`: Tracking number
- `estimated_delivery`: Estimated delivery date
- `current_location`: Current shipment location

#### Features:
- Checks if shipment already exists (idempotency)
- Generates unique tracking number
- Durable execution for shipment creation with external provider
- **Persists shipment to PostgreSQL database** (durable execution)
- Read-only tracking endpoint
- Stores shipment state in Restate for fast access

### 4. **MerchantService - VIRTUAL OBJECT**

The MerchantService is implemented as a **Restate Virtual Object**, keyed by merchant ID. It manages merchant catalog state (items and stock levels) with read and write handlers.

#### Handlers:
- `GetMerchant` (ObjectSharedContext) - Read merchant metadata and items
- `ListItems` (ObjectSharedContext) - Read paginated items
- `GetItem` (ObjectSharedContext) - Read single item
- `UpdateStock` (ObjectContext) - Mutate stock via absolute set or delta increment

#### State Stored:
- `name`: Merchant display name
- `items`: List of items `{item_id, name, quantity, price}`

#### Features:
- Pagination with `page_size`, `page_token`, `next_page_token`
- Flexible stock updates using `oneof { set_quantity, increment_delta }`
- Default quantity enforcement to 999 when creating unseen items

## Key Restate Concepts Used

### Workflows
- **Exactly-once execution** per workflow ID
- **Durable state** using `restate.Set()` and `restate.Get()`
- **Service-to-service calls** using `restate.Object()` client
- **Workflow key** accessed via `restate.Key(ctx)`
- **WorkflowContext** for write operations
- **WorkflowSharedContext** for read-only operations

### Virtual Objects
- **Keyed by unique identifier** (payment ID, shipment ID)
- **Single-writer consistency** per key
- **Built-in K/V state** using `restate.Set()` and `restate.Get()`
- **ObjectContext** for write operations
- **ObjectSharedContext** for read-only operations
- **Idempotent operations** by checking existing state

### Durable Execution
- **`restate.Run()`** for durable side effects
- Automatic retry on failures
- Journal-based execution tracking

## Data Flow

```
Client
  │
  ├─> CreateOrder (Workflow)
  │     │
  │     ├─> Store order state
  │     │
  │     ├─> ProcessPayment (Virtual Object)
  │     │     └─> Store payment state
  │     │
  │     ├─> CreateShipment (Virtual Object)
  │     │     └─> Store shipment state
  │     │
  │     └─> Update order status to COMPLETED
  │
  ├─> GetOrder (Workflow - read-only)
  │     └─> Retrieve order state
  │
  └─> TrackShipment (Virtual Object - read-only)
        └─> Retrieve shipment state
```

## Running the Application

### 1. Set Up PostgreSQL Database

See [DATABASE_SETUP.md](../DATABASE_SETUP.md) for detailed instructions.

**Quick setup:**
```bash
# Create database and user
psql -U postgres -f setup_database.sql
```

**Database Configuration:**
- Host: localhost
- Port: 5432
- Database: orderpipeline
- User: orderpipelineadmin
- Password: (empty)

### 2. Build
```bash
make proto
go build -o order-processing-pipeline ./cmd/server
```

### 3. Start the Server
```bash
make migrate-up
make run
```

The server will start on port 9081 and automatically:
- Connect to PostgreSQL
- Create database tables if they don't exist
- Start the Restate server

**Note:** The application will continue running even if database connection fails, but without persistent storage.

### 4. Register with Restate
```bash
restate deployments register http://localhost:9081
```

### 5. Invoke the Workflow
```bash
# Create an order (workflow ID = order-123)
restate workflow start order.sv1.OrderService/order-123 CreateOrder \
  --input '{"customer_id": "customer-456", "items": [{"product_id": "prod-1", "quantity": 2}]}'

# Get order status
restate workflow get order.sv1.OrderService/order-123 GetOrder \
  --input '{"order_id": "order-123"}'

# Track shipment (virtual object key = shipment-789)
restate object call order.sv1.ShippingService/shipment-789 TrackShipment \
  --input '{"shipment_id": "shipment-789"}'
```

## Benefits of This Architecture

1. **Reliability**: Workflows ensure exactly-once execution even with failures
2. **Consistency**: Virtual Objects provide single-writer consistency per key
3. **Observability**: All state changes are tracked in Restate's journal
4. **Scalability**: Virtual Objects can be distributed across multiple instances
5. **Persistent Storage**: PostgreSQL provides long-term data persistence
6. **Complex Queries**: SQL enables advanced reporting and analytics
7. **Idempotency**: Built-in idempotency for all operations
8. **Durability**: State persists across restarts and failures (both Restate and PostgreSQL)
9. **Audit Trail**: Complete history of all transactions in the database
10. **Graceful Degradation**: Application continues running even if database is unavailable

## Files

- **cmd/server/main.go** - Server wiring and service bindings
- **internal/order/workflow.go** - Order workflow handlers
- **internal/payment/object.go** - Payment virtual object
- **internal/shipping/object.go** - Shipping virtual object
- **internal/storage/postgres/db.go** - Postgres connection and queries
- **db/migrations/** - SQL migrations (schema managed via migrations)
- **scripts/setup_database.sql** - Database and user bootstrap
- **docs/** - Documentation set

## Next Steps

- Implement actual payment gateway integration in `ProcessPayment`
- Implement actual shipping provider API in `CreateShipment`
- Add more workflow handlers (CancelOrder, RefundOrder)
- Add more virtual object handlers (UpdateShipmentLocation, AddShipmentEvent)
- Add comprehensive error handling and validation
- Add unit tests using Restate's testing utilities
- Set up database backups and monitoring
- Implement database migrations for schema changes
- Add database connection pooling configuration
- Consider read replicas for scaling queries
