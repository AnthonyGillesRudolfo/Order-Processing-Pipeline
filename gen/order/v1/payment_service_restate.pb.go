// Code generated by protoc-gen-go-restate. DO NOT EDIT.
// versions:
// - protoc-gen-go-restate v0.1
// - protoc             v6.32.1
// source: payment_service.proto

package orderpb

import (
	fmt "fmt"
	sdk_go "github.com/restatedev/sdk-go"
)

// PaymentServiceClient is the client API for order.sv1.PaymentService service.
type PaymentServiceClient interface {
	ProcessPayment(opts ...sdk_go.ClientOption) sdk_go.Client[*ProcessPaymentRequest, *ProcessPaymentResponse]
	// Simulate marking a payment as completed (no real capture). Idempotent.
	MarkPaymentCompleted(opts ...sdk_go.ClientOption) sdk_go.Client[*MarkPaymentCompletedRequest, *MarkPaymentCompletedResponse]
	// Process refund for a completed payment
	ProcessRefund(opts ...sdk_go.ClientOption) sdk_go.Client[*ProcessRefundRequest, *ProcessRefundResponse]
	// Mark payment as expired and handle order cancellation
	MarkPaymentExpired(opts ...sdk_go.ClientOption) sdk_go.Client[*MarkPaymentExpiredRequest, *MarkPaymentExpiredResponse]
}

type paymentServiceClient struct {
	ctx     sdk_go.Context
	options []sdk_go.ClientOption
}

func NewPaymentServiceClient(ctx sdk_go.Context, opts ...sdk_go.ClientOption) PaymentServiceClient {
	cOpts := append([]sdk_go.ClientOption{sdk_go.WithProtoJSON}, opts...)
	return &paymentServiceClient{
		ctx,
		cOpts,
	}
}
func (c *paymentServiceClient) ProcessPayment(opts ...sdk_go.ClientOption) sdk_go.Client[*ProcessPaymentRequest, *ProcessPaymentResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*ProcessPaymentRequest](sdk_go.Service[*ProcessPaymentResponse](c.ctx, "order.sv1.PaymentService", "ProcessPayment", cOpts...))
}

func (c *paymentServiceClient) MarkPaymentCompleted(opts ...sdk_go.ClientOption) sdk_go.Client[*MarkPaymentCompletedRequest, *MarkPaymentCompletedResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*MarkPaymentCompletedRequest](sdk_go.Service[*MarkPaymentCompletedResponse](c.ctx, "order.sv1.PaymentService", "MarkPaymentCompleted", cOpts...))
}

func (c *paymentServiceClient) ProcessRefund(opts ...sdk_go.ClientOption) sdk_go.Client[*ProcessRefundRequest, *ProcessRefundResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*ProcessRefundRequest](sdk_go.Service[*ProcessRefundResponse](c.ctx, "order.sv1.PaymentService", "ProcessRefund", cOpts...))
}

func (c *paymentServiceClient) MarkPaymentExpired(opts ...sdk_go.ClientOption) sdk_go.Client[*MarkPaymentExpiredRequest, *MarkPaymentExpiredResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*MarkPaymentExpiredRequest](sdk_go.Service[*MarkPaymentExpiredResponse](c.ctx, "order.sv1.PaymentService", "MarkPaymentExpired", cOpts...))
}

// PaymentServiceServer is the server API for order.sv1.PaymentService service.
// All implementations should embed UnimplementedPaymentServiceServer
// for forward compatibility.
type PaymentServiceServer interface {
	ProcessPayment(ctx sdk_go.Context, req *ProcessPaymentRequest) (*ProcessPaymentResponse, error)
	// Simulate marking a payment as completed (no real capture). Idempotent.
	MarkPaymentCompleted(ctx sdk_go.Context, req *MarkPaymentCompletedRequest) (*MarkPaymentCompletedResponse, error)
	// Process refund for a completed payment
	ProcessRefund(ctx sdk_go.Context, req *ProcessRefundRequest) (*ProcessRefundResponse, error)
	// Mark payment as expired and handle order cancellation
	MarkPaymentExpired(ctx sdk_go.Context, req *MarkPaymentExpiredRequest) (*MarkPaymentExpiredResponse, error)
}

// UnimplementedPaymentServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentServiceServer struct{}

func (UnimplementedPaymentServiceServer) ProcessPayment(ctx sdk_go.Context, req *ProcessPaymentRequest) (*ProcessPaymentResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method ProcessPayment not implemented"), 501)
}
func (UnimplementedPaymentServiceServer) MarkPaymentCompleted(ctx sdk_go.Context, req *MarkPaymentCompletedRequest) (*MarkPaymentCompletedResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method MarkPaymentCompleted not implemented"), 501)
}
func (UnimplementedPaymentServiceServer) ProcessRefund(ctx sdk_go.Context, req *ProcessRefundRequest) (*ProcessRefundResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method ProcessRefund not implemented"), 501)
}
func (UnimplementedPaymentServiceServer) MarkPaymentExpired(ctx sdk_go.Context, req *MarkPaymentExpiredRequest) (*MarkPaymentExpiredResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method MarkPaymentExpired not implemented"), 501)
}
func (UnimplementedPaymentServiceServer) testEmbeddedByValue() {}

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
	mustEmbedUnimplementedPaymentServiceServer()
}

func NewPaymentServiceServer(srv PaymentServiceServer, opts ...sdk_go.ServiceDefinitionOption) sdk_go.ServiceDefinition {
	// If the following call panics, it indicates UnimplementedPaymentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	sOpts := append([]sdk_go.ServiceDefinitionOption{sdk_go.WithProtoJSON}, opts...)
	router := sdk_go.NewService("order.sv1.PaymentService", sOpts...)
	router = router.Handler("ProcessPayment", sdk_go.NewServiceHandler(srv.ProcessPayment))
	router = router.Handler("MarkPaymentCompleted", sdk_go.NewServiceHandler(srv.MarkPaymentCompleted))
	router = router.Handler("ProcessRefund", sdk_go.NewServiceHandler(srv.ProcessRefund))
	router = router.Handler("MarkPaymentExpired", sdk_go.NewServiceHandler(srv.MarkPaymentExpired))
	return router
}
